
syntax = "proto3";

package BringAutoDaemon;

/**
 * Car status information.
 * From Client to Server only
 */
message CarStatus {

  message Telemetry {
    /**
     * vehicle speed in [m/s]
     * - positive value implies Forward car moving,
     * - negative value implies Backward car moving,
     * - zero value implies that the car stays at a place.
     */
    double speed = 1;

    /**
     * Fuel of the car in percents.
     * - 0.0 means empty battery or tank,
     * - 1.0 means full battery or tank.
     * Interpolation between 0.0 and 1.0 must be linear!
     */
    double fuel = 2;

    /**
     * Car position in the global map (WGS84)
     */
    Position position = 3;
  }

  message Position {
    /**
     * WGS84 latitude,
     */
    double latitude = 1;

    /**
     * WGS84 longitude
     */
    double longitude = 2;

    /**
     * altitude in [m]
     */
    double altitude = 3;
  }

  /**
   * State of the car according to The Autonomy system.
   * Change of the State is only possible as described - no side effects allowed!
   */
  enum State {
    /**
     * Car is in IDLE mode. Waiting for CarCommand message receive.
     * This state assume that the CarStatus::telemetry::speed is zero!
     * State transitions:
     * - To switch car to the DRIVE the CarCommand::action = START
     * must be received and there must be a stop where to drive. Otherwise
     * no change must be performed.
     */
    IDLE = 0;

    /**
     * Car is driving (to the target stop).
     * State transitions:
     * - If the CarCommand::control::action = STOP is received
     * the CarStatus::state must change to IDLE.
     */
    DRIVE = 1;

    /**
     * Car is in the specified stop. It does not imply that the car is IDLE.
     * This state assume that the CarStatus::telemetry::speed is zero!
     * State transitions:
     * - To switch car to the IDLE the CarCommand::action = STOP
     * must be received.
     * - To switch car to the IDLE the CarCommand::action = START must be received
     * and the car shall be in the last stop!
     * - To switch car to the DRIVE the CarCommand::action = START
     * must be received and there must be a stop where to drive.
     */
    IN_STOP = 2;

    /**
     * There is an Obstacle which will cause collision if not removed.
     * The transition from this state to another is defined by The Autonomy implementation.
     */
    OBSTACLE = 3;

    /**
     * Car is in an error state.
     * State reflects that the car is in critical condition and needs an assistance.
     * The transition from this state to another is defined by The Autonomy implementation.
     */
    ERROR = 4;
  }

  /**
   * Telemetry
   */
  Telemetry telemetry = 1;

  /**
   * State of the Car.
   * If not set Car is in the IDLE state!
   * OPTIONAL
   */
  State state = 2;

  /**
   * Name of the stop as specified in CarCommand::stops.
   * If the CarStatus::state = IDLE the stop value is irrelevant.
   * If the CarStatus::state = DRIVE the stop is the next stop where the car drive.
   * If the CarStatus::state = IN_STOP the stop is the stop where the car is.
   * OPTIONAL
   */
  Stop stop = 3;
}



/**
 * Car commands received from BringAuto cloud
 * From BAD to Client only.
 */
message CarCommand {

  /**
   * Action which car must take.
   * Received action has an immediate effect to the state of the car (CarStatus::state)
   * @see CarStatus::State
   */
  enum Action {
    /**
     * No action performed. Used as a default value.
     * Does not interact with CarCommand::stops logic.
     */
    NO_ACTION = 0;

    /**
     * Stop The car!
     * Independent on content of CarCommands::stops
     */
    STOP = 1;

    /**
     * Start the car!
     * If there are stops in CarCommands::stops the car shall start driving to the next stop.
     */
    START = 2;
  }

  /**
   * List of stops where the car shall go. Car goes from one stop to another by the order specified by the list.
   * If the list is empty the previous non-empty received list of stops is in tact.
   * If the list is not empty and is equal to the previous received list of stops we behave like
   * the list of stops in already received message is empty.
   * (we assume that the list is empty before the first CarCommand is received from BAD)
   * (NOTE: If the list is not empty and is different from previous received list --> ??? to discussion)
   * OPTIONAL
   */
  repeated Stop stops = 1;

  Action action = 2;

}

/**
 * Stop on the route.
 */
message Stop {

  /**
   * The name of the stop where to go.
   * Once the car arrives to the target stop it must change CarStatus::state to IN_STOP
   * and wait for CarCommands::action == START to drive to the another stop.
   */
  string to = 1;

}
