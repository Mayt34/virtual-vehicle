// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: CarStateProtocol.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_CarStateProtocol_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_CarStateProtocol_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3017000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3017003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_CarStateProtocol_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_CarStateProtocol_2eproto {
	static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
	PROTOBUF_SECTION_VARIABLE(protodesc_cold);
	static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
	PROTOBUF_SECTION_VARIABLE(protodesc_cold);
	static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[5]
	PROTOBUF_SECTION_VARIABLE(protodesc_cold);
	static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
	static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
	static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_CarStateProtocol_2eproto;
namespace CarStateProtocol {
class CarCommand;
struct CarCommandDefaultTypeInternal;
extern CarCommandDefaultTypeInternal _CarCommand_default_instance_;
class CarStatus;
struct CarStatusDefaultTypeInternal;
extern CarStatusDefaultTypeInternal _CarStatus_default_instance_;
class CarStatus_Position;
struct CarStatus_PositionDefaultTypeInternal;
extern CarStatus_PositionDefaultTypeInternal _CarStatus_Position_default_instance_;
class CarStatus_Telemetry;
struct CarStatus_TelemetryDefaultTypeInternal;
extern CarStatus_TelemetryDefaultTypeInternal _CarStatus_Telemetry_default_instance_;
class Stop;
struct StopDefaultTypeInternal;
extern StopDefaultTypeInternal _Stop_default_instance_;
}  // namespace CarStateProtocol
PROTOBUF_NAMESPACE_OPEN
template<> ::CarStateProtocol::CarCommand* Arena::CreateMaybeMessage<::CarStateProtocol::CarCommand>(Arena*);
template<> ::CarStateProtocol::CarStatus* Arena::CreateMaybeMessage<::CarStateProtocol::CarStatus>(Arena*);
template<> ::CarStateProtocol::CarStatus_Position* Arena::CreateMaybeMessage<::CarStateProtocol::CarStatus_Position>(Arena*);
template<> ::CarStateProtocol::CarStatus_Telemetry* Arena::CreateMaybeMessage<::CarStateProtocol::CarStatus_Telemetry>(Arena*);
template<> ::CarStateProtocol::Stop* Arena::CreateMaybeMessage<::CarStateProtocol::Stop>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace CarStateProtocol {

enum CarStatus_State : int {
	CarStatus_State_IDLE = 0,
	CarStatus_State_DRIVE = 1,
	CarStatus_State_IN_STOP = 2,
	CarStatus_State_OBSTACLE = 3,
	CarStatus_State_ERROR = 4,
	CarStatus_State_CarStatus_State_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
	CarStatus_State_CarStatus_State_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool CarStatus_State_IsValid(int value);
constexpr CarStatus_State CarStatus_State_State_MIN = CarStatus_State_IDLE;
constexpr CarStatus_State CarStatus_State_State_MAX = CarStatus_State_ERROR;
constexpr int CarStatus_State_State_ARRAYSIZE = CarStatus_State_State_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CarStatus_State_descriptor();
template<typename T>
inline const std::string& CarStatus_State_Name(T enum_t_value) {
	static_assert(::std::is_same<T, CarStatus_State>::value ||
				  ::std::is_integral<T>::value,
				  "Incorrect type passed to function CarStatus_State_Name.");
	return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
			CarStatus_State_descriptor(), enum_t_value);
}
inline bool CarStatus_State_Parse(
		::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CarStatus_State* value) {
	return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CarStatus_State>(
			CarStatus_State_descriptor(), name, value);
}
enum CarCommand_Action : int {
	CarCommand_Action_NO_ACTION = 0,
	CarCommand_Action_STOP = 1,
	CarCommand_Action_START = 2,
	CarCommand_Action_CarCommand_Action_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
	CarCommand_Action_CarCommand_Action_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool CarCommand_Action_IsValid(int value);
constexpr CarCommand_Action CarCommand_Action_Action_MIN = CarCommand_Action_NO_ACTION;
constexpr CarCommand_Action CarCommand_Action_Action_MAX = CarCommand_Action_START;
constexpr int CarCommand_Action_Action_ARRAYSIZE = CarCommand_Action_Action_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CarCommand_Action_descriptor();
template<typename T>
inline const std::string& CarCommand_Action_Name(T enum_t_value) {
	static_assert(::std::is_same<T, CarCommand_Action>::value ||
				  ::std::is_integral<T>::value,
				  "Incorrect type passed to function CarCommand_Action_Name.");
	return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
			CarCommand_Action_descriptor(), enum_t_value);
}
inline bool CarCommand_Action_Parse(
		::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CarCommand_Action* value) {
	return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CarCommand_Action>(
			CarCommand_Action_descriptor(), name, value);
}
// ===================================================================

class CarStatus_Telemetry final :
		public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CarStateProtocol.CarStatus.Telemetry) */ {
public:
	inline CarStatus_Telemetry() : CarStatus_Telemetry(nullptr) {}
	~CarStatus_Telemetry() override;
	explicit constexpr CarStatus_Telemetry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

	CarStatus_Telemetry(const CarStatus_Telemetry& from);
	CarStatus_Telemetry(CarStatus_Telemetry&& from) noexcept
			: CarStatus_Telemetry() {
		*this = ::std::move(from);
	}

	inline CarStatus_Telemetry& operator=(const CarStatus_Telemetry& from) {
		CopyFrom(from);
		return *this;
	}
	inline CarStatus_Telemetry& operator=(CarStatus_Telemetry&& from) noexcept {
		if (this == &from) return *this;
		if (GetOwningArena() == from.GetOwningArena()) {
			InternalSwap(&from);
		} else {
			CopyFrom(from);
		}
		return *this;
	}

	static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
		return GetDescriptor();
	}
	static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
		return default_instance().GetMetadata().descriptor;
	}
	static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
		return default_instance().GetMetadata().reflection;
	}
	static const CarStatus_Telemetry& default_instance() {
		return *internal_default_instance();
	}
	static inline const CarStatus_Telemetry* internal_default_instance() {
		return reinterpret_cast<const CarStatus_Telemetry*>(
				&_CarStatus_Telemetry_default_instance_);
	}
	static constexpr int kIndexInFileMessages =
			0;

	friend void swap(CarStatus_Telemetry& a, CarStatus_Telemetry& b) {
		a.Swap(&b);
	}
	inline void Swap(CarStatus_Telemetry* other) {
		if (other == this) return;
		if (GetOwningArena() == other->GetOwningArena()) {
			InternalSwap(other);
		} else {
			::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
		}
	}
	void UnsafeArenaSwap(CarStatus_Telemetry* other) {
		if (other == this) return;
				GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
		InternalSwap(other);
	}

	// implements Message ----------------------------------------------

	inline CarStatus_Telemetry* New() const final {
		return new CarStatus_Telemetry();
	}

	CarStatus_Telemetry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
		return CreateMaybeMessage<CarStatus_Telemetry>(arena);
	}
	using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
	void CopyFrom(const CarStatus_Telemetry& from);
	using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
	void MergeFrom(const CarStatus_Telemetry& from);
private:
	static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
public:
	PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
	bool IsInitialized() const final;

	size_t ByteSizeLong() const final;
	const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
	::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
			::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
	int GetCachedSize() const final { return _cached_size_.Get(); }

private:
	void SharedCtor();
	void SharedDtor();
	void SetCachedSize(int size) const final;
	void InternalSwap(CarStatus_Telemetry* other);
	friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
	static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
		return "CarStateProtocol.CarStatus.Telemetry";
	}
protected:
	explicit CarStatus_Telemetry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
								 bool is_message_owned = false);
private:
	static void ArenaDtor(void* object);
	inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
public:

	static const ClassData _class_data_;
	const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

	::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

	// nested types ----------------------------------------------------

	// accessors -------------------------------------------------------

	enum : int {
		kPositionFieldNumber = 3,
		kSpeedFieldNumber = 1,
		kFuelFieldNumber = 2,
	};
	// .CarStateProtocol.CarStatus.Position position = 3;
	bool has_position() const;
private:
	bool _internal_has_position() const;
public:
	void clear_position();
	const ::CarStateProtocol::CarStatus_Position& position() const;
	PROTOBUF_MUST_USE_RESULT ::CarStateProtocol::CarStatus_Position* release_position();
	::CarStateProtocol::CarStatus_Position* mutable_position();
	void set_allocated_position(::CarStateProtocol::CarStatus_Position* position);
private:
	const ::CarStateProtocol::CarStatus_Position& _internal_position() const;
	::CarStateProtocol::CarStatus_Position* _internal_mutable_position();
public:
	void unsafe_arena_set_allocated_position(
			::CarStateProtocol::CarStatus_Position* position);
	::CarStateProtocol::CarStatus_Position* unsafe_arena_release_position();

	// double speed = 1;
	void clear_speed();
	double speed() const;
	void set_speed(double value);
private:
	double _internal_speed() const;
	void _internal_set_speed(double value);
public:

	// double fuel = 2;
	void clear_fuel();
	double fuel() const;
	void set_fuel(double value);
private:
	double _internal_fuel() const;
	void _internal_set_fuel(double value);
public:

	// @@protoc_insertion_point(class_scope:CarStateProtocol.CarStatus.Telemetry)
private:
	class _Internal;

	template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
	typedef void InternalArenaConstructable_;
	typedef void DestructorSkippable_;
	::CarStateProtocol::CarStatus_Position* position_;
	double speed_;
	double fuel_;
	mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
	friend struct ::TableStruct_CarStateProtocol_2eproto;
};
// -------------------------------------------------------------------

class CarStatus_Position final :
		public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CarStateProtocol.CarStatus.Position) */ {
public:
	inline CarStatus_Position() : CarStatus_Position(nullptr) {}
	~CarStatus_Position() override;
	explicit constexpr CarStatus_Position(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

	CarStatus_Position(const CarStatus_Position& from);
	CarStatus_Position(CarStatus_Position&& from) noexcept
			: CarStatus_Position() {
		*this = ::std::move(from);
	}

	inline CarStatus_Position& operator=(const CarStatus_Position& from) {
		CopyFrom(from);
		return *this;
	}
	inline CarStatus_Position& operator=(CarStatus_Position&& from) noexcept {
		if (this == &from) return *this;
		if (GetOwningArena() == from.GetOwningArena()) {
			InternalSwap(&from);
		} else {
			CopyFrom(from);
		}
		return *this;
	}

	static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
		return GetDescriptor();
	}
	static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
		return default_instance().GetMetadata().descriptor;
	}
	static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
		return default_instance().GetMetadata().reflection;
	}
	static const CarStatus_Position& default_instance() {
		return *internal_default_instance();
	}
	static inline const CarStatus_Position* internal_default_instance() {
		return reinterpret_cast<const CarStatus_Position*>(
				&_CarStatus_Position_default_instance_);
	}
	static constexpr int kIndexInFileMessages =
			1;

	friend void swap(CarStatus_Position& a, CarStatus_Position& b) {
		a.Swap(&b);
	}
	inline void Swap(CarStatus_Position* other) {
		if (other == this) return;
		if (GetOwningArena() == other->GetOwningArena()) {
			InternalSwap(other);
		} else {
			::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
		}
	}
	void UnsafeArenaSwap(CarStatus_Position* other) {
		if (other == this) return;
				GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
		InternalSwap(other);
	}

	// implements Message ----------------------------------------------

	inline CarStatus_Position* New() const final {
		return new CarStatus_Position();
	}

	CarStatus_Position* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
		return CreateMaybeMessage<CarStatus_Position>(arena);
	}
	using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
	void CopyFrom(const CarStatus_Position& from);
	using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
	void MergeFrom(const CarStatus_Position& from);
private:
	static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
public:
	PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
	bool IsInitialized() const final;

	size_t ByteSizeLong() const final;
	const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
	::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
			::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
	int GetCachedSize() const final { return _cached_size_.Get(); }

private:
	void SharedCtor();
	void SharedDtor();
	void SetCachedSize(int size) const final;
	void InternalSwap(CarStatus_Position* other);
	friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
	static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
		return "CarStateProtocol.CarStatus.Position";
	}
protected:
	explicit CarStatus_Position(::PROTOBUF_NAMESPACE_ID::Arena* arena,
								bool is_message_owned = false);
private:
	static void ArenaDtor(void* object);
	inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
public:

	static const ClassData _class_data_;
	const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

	::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

	// nested types ----------------------------------------------------

	// accessors -------------------------------------------------------

	enum : int {
		kLatitudeFieldNumber = 1,
		kLongitudeFieldNumber = 2,
		kAltitudeFieldNumber = 3,
	};
	// double latitude = 1;
	void clear_latitude();
	double latitude() const;
	void set_latitude(double value);
private:
	double _internal_latitude() const;
	void _internal_set_latitude(double value);
public:

	// double longitude = 2;
	void clear_longitude();
	double longitude() const;
	void set_longitude(double value);
private:
	double _internal_longitude() const;
	void _internal_set_longitude(double value);
public:

	// double altitude = 3;
	void clear_altitude();
	double altitude() const;
	void set_altitude(double value);
private:
	double _internal_altitude() const;
	void _internal_set_altitude(double value);
public:

	// @@protoc_insertion_point(class_scope:CarStateProtocol.CarStatus.Position)
private:
	class _Internal;

	template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
	typedef void InternalArenaConstructable_;
	typedef void DestructorSkippable_;
	double latitude_;
	double longitude_;
	double altitude_;
	mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
	friend struct ::TableStruct_CarStateProtocol_2eproto;
};
// -------------------------------------------------------------------

class CarStatus final :
		public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CarStateProtocol.CarStatus) */ {
public:
	inline CarStatus() : CarStatus(nullptr) {}
	~CarStatus() override;
	explicit constexpr CarStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

	CarStatus(const CarStatus& from);
	CarStatus(CarStatus&& from) noexcept
			: CarStatus() {
		*this = ::std::move(from);
	}

	inline CarStatus& operator=(const CarStatus& from) {
		CopyFrom(from);
		return *this;
	}
	inline CarStatus& operator=(CarStatus&& from) noexcept {
		if (this == &from) return *this;
		if (GetOwningArena() == from.GetOwningArena()) {
			InternalSwap(&from);
		} else {
			CopyFrom(from);
		}
		return *this;
	}

	static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
		return GetDescriptor();
	}
	static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
		return default_instance().GetMetadata().descriptor;
	}
	static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
		return default_instance().GetMetadata().reflection;
	}
	static const CarStatus& default_instance() {
		return *internal_default_instance();
	}
	static inline const CarStatus* internal_default_instance() {
		return reinterpret_cast<const CarStatus*>(
				&_CarStatus_default_instance_);
	}
	static constexpr int kIndexInFileMessages =
			2;

	friend void swap(CarStatus& a, CarStatus& b) {
		a.Swap(&b);
	}
	inline void Swap(CarStatus* other) {
		if (other == this) return;
		if (GetOwningArena() == other->GetOwningArena()) {
			InternalSwap(other);
		} else {
			::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
		}
	}
	void UnsafeArenaSwap(CarStatus* other) {
		if (other == this) return;
				GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
		InternalSwap(other);
	}

	// implements Message ----------------------------------------------

	inline CarStatus* New() const final {
		return new CarStatus();
	}

	CarStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
		return CreateMaybeMessage<CarStatus>(arena);
	}
	using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
	void CopyFrom(const CarStatus& from);
	using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
	void MergeFrom(const CarStatus& from);
private:
	static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
public:
	PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
	bool IsInitialized() const final;

	size_t ByteSizeLong() const final;
	const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
	::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
			::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
	int GetCachedSize() const final { return _cached_size_.Get(); }

private:
	void SharedCtor();
	void SharedDtor();
	void SetCachedSize(int size) const final;
	void InternalSwap(CarStatus* other);
	friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
	static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
		return "CarStateProtocol.CarStatus";
	}
protected:
	explicit CarStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
					   bool is_message_owned = false);
private:
	static void ArenaDtor(void* object);
	inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
public:

	static const ClassData _class_data_;
	const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

	::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

	// nested types ----------------------------------------------------

	typedef CarStatus_Telemetry Telemetry;
	typedef CarStatus_Position Position;

	typedef CarStatus_State State;
	static constexpr State IDLE =
			CarStatus_State_IDLE;
	static constexpr State DRIVE =
			CarStatus_State_DRIVE;
	static constexpr State IN_STOP =
			CarStatus_State_IN_STOP;
	static constexpr State OBSTACLE =
			CarStatus_State_OBSTACLE;
	static constexpr State ERROR =
			CarStatus_State_ERROR;
	static inline bool State_IsValid(int value) {
		return CarStatus_State_IsValid(value);
	}
	static constexpr State State_MIN =
			CarStatus_State_State_MIN;
	static constexpr State State_MAX =
			CarStatus_State_State_MAX;
	static constexpr int State_ARRAYSIZE =
			CarStatus_State_State_ARRAYSIZE;
	static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
	State_descriptor() {
		return CarStatus_State_descriptor();
	}
	template<typename T>
	static inline const std::string& State_Name(T enum_t_value) {
		static_assert(::std::is_same<T, State>::value ||
					  ::std::is_integral<T>::value,
					  "Incorrect type passed to function State_Name.");
		return CarStatus_State_Name(enum_t_value);
	}
	static inline bool State_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
								   State* value) {
		return CarStatus_State_Parse(name, value);
	}

	// accessors -------------------------------------------------------

	enum : int {
		kTelemetryFieldNumber = 1,
		kStopFieldNumber = 3,
		kStateFieldNumber = 2,
	};
	// .CarStateProtocol.CarStatus.Telemetry telemetry = 1;
	bool has_telemetry() const;
private:
	bool _internal_has_telemetry() const;
public:
	void clear_telemetry();
	const ::CarStateProtocol::CarStatus_Telemetry& telemetry() const;
	PROTOBUF_MUST_USE_RESULT ::CarStateProtocol::CarStatus_Telemetry* release_telemetry();
	::CarStateProtocol::CarStatus_Telemetry* mutable_telemetry();
	void set_allocated_telemetry(::CarStateProtocol::CarStatus_Telemetry* telemetry);
private:
	const ::CarStateProtocol::CarStatus_Telemetry& _internal_telemetry() const;
	::CarStateProtocol::CarStatus_Telemetry* _internal_mutable_telemetry();
public:
	void unsafe_arena_set_allocated_telemetry(
			::CarStateProtocol::CarStatus_Telemetry* telemetry);
	::CarStateProtocol::CarStatus_Telemetry* unsafe_arena_release_telemetry();

	// .CarStateProtocol.Stop stop = 3;
	bool has_stop() const;
private:
	bool _internal_has_stop() const;
public:
	void clear_stop();
	const ::CarStateProtocol::Stop& stop() const;
	PROTOBUF_MUST_USE_RESULT ::CarStateProtocol::Stop* release_stop();
	::CarStateProtocol::Stop* mutable_stop();
	void set_allocated_stop(::CarStateProtocol::Stop* stop);
private:
	const ::CarStateProtocol::Stop& _internal_stop() const;
	::CarStateProtocol::Stop* _internal_mutable_stop();
public:
	void unsafe_arena_set_allocated_stop(
			::CarStateProtocol::Stop* stop);
	::CarStateProtocol::Stop* unsafe_arena_release_stop();

	// .CarStateProtocol.CarStatus.State state = 2;
	void clear_state();
	::CarStateProtocol::CarStatus_State state() const;
	void set_state(::CarStateProtocol::CarStatus_State value);
private:
	::CarStateProtocol::CarStatus_State _internal_state() const;
	void _internal_set_state(::CarStateProtocol::CarStatus_State value);
public:

	// @@protoc_insertion_point(class_scope:CarStateProtocol.CarStatus)
private:
	class _Internal;

	template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
	typedef void InternalArenaConstructable_;
	typedef void DestructorSkippable_;
	::CarStateProtocol::CarStatus_Telemetry* telemetry_;
	::CarStateProtocol::Stop* stop_;
	int state_;
	mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
	friend struct ::TableStruct_CarStateProtocol_2eproto;
};
// -------------------------------------------------------------------

class CarCommand final :
		public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CarStateProtocol.CarCommand) */ {
public:
	inline CarCommand() : CarCommand(nullptr) {}
	~CarCommand() override;
	explicit constexpr CarCommand(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

	CarCommand(const CarCommand& from);
	CarCommand(CarCommand&& from) noexcept
			: CarCommand() {
		*this = ::std::move(from);
	}

	inline CarCommand& operator=(const CarCommand& from) {
		CopyFrom(from);
		return *this;
	}
	inline CarCommand& operator=(CarCommand&& from) noexcept {
		if (this == &from) return *this;
		if (GetOwningArena() == from.GetOwningArena()) {
			InternalSwap(&from);
		} else {
			CopyFrom(from);
		}
		return *this;
	}

	static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
		return GetDescriptor();
	}
	static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
		return default_instance().GetMetadata().descriptor;
	}
	static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
		return default_instance().GetMetadata().reflection;
	}
	static const CarCommand& default_instance() {
		return *internal_default_instance();
	}
	static inline const CarCommand* internal_default_instance() {
		return reinterpret_cast<const CarCommand*>(
				&_CarCommand_default_instance_);
	}
	static constexpr int kIndexInFileMessages =
			3;

	friend void swap(CarCommand& a, CarCommand& b) {
		a.Swap(&b);
	}
	inline void Swap(CarCommand* other) {
		if (other == this) return;
		if (GetOwningArena() == other->GetOwningArena()) {
			InternalSwap(other);
		} else {
			::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
		}
	}
	void UnsafeArenaSwap(CarCommand* other) {
		if (other == this) return;
				GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
		InternalSwap(other);
	}

	// implements Message ----------------------------------------------

	inline CarCommand* New() const final {
		return new CarCommand();
	}

	CarCommand* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
		return CreateMaybeMessage<CarCommand>(arena);
	}
	using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
	void CopyFrom(const CarCommand& from);
	using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
	void MergeFrom(const CarCommand& from);
private:
	static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
public:
	PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
	bool IsInitialized() const final;

	size_t ByteSizeLong() const final;
	const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
	::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
			::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
	int GetCachedSize() const final { return _cached_size_.Get(); }

private:
	void SharedCtor();
	void SharedDtor();
	void SetCachedSize(int size) const final;
	void InternalSwap(CarCommand* other);
	friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
	static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
		return "CarStateProtocol.CarCommand";
	}
protected:
	explicit CarCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena,
						bool is_message_owned = false);
private:
	static void ArenaDtor(void* object);
	inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
public:

	static const ClassData _class_data_;
	const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

	::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

	// nested types ----------------------------------------------------

	typedef CarCommand_Action Action;
	static constexpr Action NO_ACTION =
			CarCommand_Action_NO_ACTION;
	static constexpr Action STOP =
			CarCommand_Action_STOP;
	static constexpr Action START =
			CarCommand_Action_START;
	static inline bool Action_IsValid(int value) {
		return CarCommand_Action_IsValid(value);
	}
	static constexpr Action Action_MIN =
			CarCommand_Action_Action_MIN;
	static constexpr Action Action_MAX =
			CarCommand_Action_Action_MAX;
	static constexpr int Action_ARRAYSIZE =
			CarCommand_Action_Action_ARRAYSIZE;
	static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
	Action_descriptor() {
		return CarCommand_Action_descriptor();
	}
	template<typename T>
	static inline const std::string& Action_Name(T enum_t_value) {
		static_assert(::std::is_same<T, Action>::value ||
					  ::std::is_integral<T>::value,
					  "Incorrect type passed to function Action_Name.");
		return CarCommand_Action_Name(enum_t_value);
	}
	static inline bool Action_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
									Action* value) {
		return CarCommand_Action_Parse(name, value);
	}

	// accessors -------------------------------------------------------

	enum : int {
		kStopsFieldNumber = 1,
		kActionFieldNumber = 2,
	};
	// repeated .CarStateProtocol.Stop stops = 1;
	int stops_size() const;
private:
	int _internal_stops_size() const;
public:
	void clear_stops();
	::CarStateProtocol::Stop* mutable_stops(int index);
	::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CarStateProtocol::Stop >*
	mutable_stops();
private:
	const ::CarStateProtocol::Stop& _internal_stops(int index) const;
	::CarStateProtocol::Stop* _internal_add_stops();
public:
	const ::CarStateProtocol::Stop& stops(int index) const;
	::CarStateProtocol::Stop* add_stops();
	const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CarStateProtocol::Stop >&
	stops() const;

	// .CarStateProtocol.CarCommand.Action action = 2;
	void clear_action();
	::CarStateProtocol::CarCommand_Action action() const;
	void set_action(::CarStateProtocol::CarCommand_Action value);
private:
	::CarStateProtocol::CarCommand_Action _internal_action() const;
	void _internal_set_action(::CarStateProtocol::CarCommand_Action value);
public:

	// @@protoc_insertion_point(class_scope:CarStateProtocol.CarCommand)
private:
	class _Internal;

	template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
	typedef void InternalArenaConstructable_;
	typedef void DestructorSkippable_;
	::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CarStateProtocol::Stop > stops_;
	int action_;
	mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
	friend struct ::TableStruct_CarStateProtocol_2eproto;
};
// -------------------------------------------------------------------

class Stop final :
		public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CarStateProtocol.Stop) */ {
public:
	inline Stop() : Stop(nullptr) {}
	~Stop() override;
	explicit constexpr Stop(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

	Stop(const Stop& from);
	Stop(Stop&& from) noexcept
			: Stop() {
		*this = ::std::move(from);
	}

	inline Stop& operator=(const Stop& from) {
		CopyFrom(from);
		return *this;
	}
	inline Stop& operator=(Stop&& from) noexcept {
		if (this == &from) return *this;
		if (GetOwningArena() == from.GetOwningArena()) {
			InternalSwap(&from);
		} else {
			CopyFrom(from);
		}
		return *this;
	}

	static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
		return GetDescriptor();
	}
	static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
		return default_instance().GetMetadata().descriptor;
	}
	static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
		return default_instance().GetMetadata().reflection;
	}
	static const Stop& default_instance() {
		return *internal_default_instance();
	}
	static inline const Stop* internal_default_instance() {
		return reinterpret_cast<const Stop*>(
				&_Stop_default_instance_);
	}
	static constexpr int kIndexInFileMessages =
			4;

	friend void swap(Stop& a, Stop& b) {
		a.Swap(&b);
	}
	inline void Swap(Stop* other) {
		if (other == this) return;
		if (GetOwningArena() == other->GetOwningArena()) {
			InternalSwap(other);
		} else {
			::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
		}
	}
	void UnsafeArenaSwap(Stop* other) {
		if (other == this) return;
				GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
		InternalSwap(other);
	}

	// implements Message ----------------------------------------------

	inline Stop* New() const final {
		return new Stop();
	}

	Stop* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
		return CreateMaybeMessage<Stop>(arena);
	}
	using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
	void CopyFrom(const Stop& from);
	using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
	void MergeFrom(const Stop& from);
private:
	static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
public:
	PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
	bool IsInitialized() const final;

	size_t ByteSizeLong() const final;
	const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
	::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
			::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
	int GetCachedSize() const final { return _cached_size_.Get(); }

private:
	void SharedCtor();
	void SharedDtor();
	void SetCachedSize(int size) const final;
	void InternalSwap(Stop* other);
	friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
	static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
		return "CarStateProtocol.Stop";
	}
protected:
	explicit Stop(::PROTOBUF_NAMESPACE_ID::Arena* arena,
				  bool is_message_owned = false);
private:
	static void ArenaDtor(void* object);
	inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
public:

	static const ClassData _class_data_;
	const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

	::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

	// nested types ----------------------------------------------------

	// accessors -------------------------------------------------------

	enum : int {
		kToFieldNumber = 1,
	};
	// string to = 1;
	void clear_to();
	const std::string& to() const;
	template <typename ArgT0 = const std::string&, typename... ArgT>
	void set_to(ArgT0&& arg0, ArgT... args);
	std::string* mutable_to();
	PROTOBUF_MUST_USE_RESULT std::string* release_to();
	void set_allocated_to(std::string* to);
private:
	const std::string& _internal_to() const;
	inline PROTOBUF_ALWAYS_INLINE void _internal_set_to(const std::string& value);
	std::string* _internal_mutable_to();
public:

	// @@protoc_insertion_point(class_scope:CarStateProtocol.Stop)
private:
	class _Internal;

	template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
	typedef void InternalArenaConstructable_;
	typedef void DestructorSkippable_;
	::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr to_;
	mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
	friend struct ::TableStruct_CarStateProtocol_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// CarStatus_Telemetry

// double speed = 1;
inline void CarStatus_Telemetry::clear_speed() {
	speed_ = 0;
}
inline double CarStatus_Telemetry::_internal_speed() const {
	return speed_;
}
inline double CarStatus_Telemetry::speed() const {
	// @@protoc_insertion_point(field_get:CarStateProtocol.CarStatus.Telemetry.speed)
	return _internal_speed();
}
inline void CarStatus_Telemetry::_internal_set_speed(double value) {

	speed_ = value;
}
inline void CarStatus_Telemetry::set_speed(double value) {
	_internal_set_speed(value);
	// @@protoc_insertion_point(field_set:CarStateProtocol.CarStatus.Telemetry.speed)
}

// double fuel = 2;
inline void CarStatus_Telemetry::clear_fuel() {
	fuel_ = 0;
}
inline double CarStatus_Telemetry::_internal_fuel() const {
	return fuel_;
}
inline double CarStatus_Telemetry::fuel() const {
	// @@protoc_insertion_point(field_get:CarStateProtocol.CarStatus.Telemetry.fuel)
	return _internal_fuel();
}
inline void CarStatus_Telemetry::_internal_set_fuel(double value) {

	fuel_ = value;
}
inline void CarStatus_Telemetry::set_fuel(double value) {
	_internal_set_fuel(value);
	// @@protoc_insertion_point(field_set:CarStateProtocol.CarStatus.Telemetry.fuel)
}

// .CarStateProtocol.CarStatus.Position position = 3;
inline bool CarStatus_Telemetry::_internal_has_position() const {
	return this != internal_default_instance() && position_ != nullptr;
}
inline bool CarStatus_Telemetry::has_position() const {
	return _internal_has_position();
}
inline void CarStatus_Telemetry::clear_position() {
	if (GetArenaForAllocation() == nullptr && position_ != nullptr) {
		delete position_;
	}
	position_ = nullptr;
}
inline const ::CarStateProtocol::CarStatus_Position& CarStatus_Telemetry::_internal_position() const {
	const ::CarStateProtocol::CarStatus_Position* p = position_;
	return p != nullptr ? *p : reinterpret_cast<const ::CarStateProtocol::CarStatus_Position&>(
			::CarStateProtocol::_CarStatus_Position_default_instance_);
}
inline const ::CarStateProtocol::CarStatus_Position& CarStatus_Telemetry::position() const {
	// @@protoc_insertion_point(field_get:CarStateProtocol.CarStatus.Telemetry.position)
	return _internal_position();
}
inline void CarStatus_Telemetry::unsafe_arena_set_allocated_position(
		::CarStateProtocol::CarStatus_Position* position) {
	if (GetArenaForAllocation() == nullptr) {
		delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(position_);
	}
	position_ = position;
	if (position) {

	} else {

	}
	// @@protoc_insertion_point(field_unsafe_arena_set_allocated:CarStateProtocol.CarStatus.Telemetry.position)
}
inline ::CarStateProtocol::CarStatus_Position* CarStatus_Telemetry::release_position() {

	::CarStateProtocol::CarStatus_Position* temp = position_;
	position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
	auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
	if (GetArenaForAllocation() != nullptr) {
		temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
	}
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
	return temp;
}
inline ::CarStateProtocol::CarStatus_Position* CarStatus_Telemetry::unsafe_arena_release_position() {
	// @@protoc_insertion_point(field_release:CarStateProtocol.CarStatus.Telemetry.position)

	::CarStateProtocol::CarStatus_Position* temp = position_;
	position_ = nullptr;
	return temp;
}
inline ::CarStateProtocol::CarStatus_Position* CarStatus_Telemetry::_internal_mutable_position() {

	if (position_ == nullptr) {
		auto* p = CreateMaybeMessage<::CarStateProtocol::CarStatus_Position>(GetArenaForAllocation());
		position_ = p;
	}
	return position_;
}
inline ::CarStateProtocol::CarStatus_Position* CarStatus_Telemetry::mutable_position() {
	::CarStateProtocol::CarStatus_Position* _msg = _internal_mutable_position();
	// @@protoc_insertion_point(field_mutable:CarStateProtocol.CarStatus.Telemetry.position)
	return _msg;
}
inline void CarStatus_Telemetry::set_allocated_position(::CarStateProtocol::CarStatus_Position* position) {
	::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
	if (message_arena == nullptr) {
		delete position_;
	}
	if (position) {
		::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
				::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CarStateProtocol::CarStatus_Position>::GetOwningArena(position);
		if (message_arena != submessage_arena) {
			position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
					message_arena, position, submessage_arena);
		}

	} else {

	}
	position_ = position;
	// @@protoc_insertion_point(field_set_allocated:CarStateProtocol.CarStatus.Telemetry.position)
}

// -------------------------------------------------------------------

// CarStatus_Position

// double latitude = 1;
inline void CarStatus_Position::clear_latitude() {
	latitude_ = 0;
}
inline double CarStatus_Position::_internal_latitude() const {
	return latitude_;
}
inline double CarStatus_Position::latitude() const {
	// @@protoc_insertion_point(field_get:CarStateProtocol.CarStatus.Position.latitude)
	return _internal_latitude();
}
inline void CarStatus_Position::_internal_set_latitude(double value) {

	latitude_ = value;
}
inline void CarStatus_Position::set_latitude(double value) {
	_internal_set_latitude(value);
	// @@protoc_insertion_point(field_set:CarStateProtocol.CarStatus.Position.latitude)
}

// double longitude = 2;
inline void CarStatus_Position::clear_longitude() {
	longitude_ = 0;
}
inline double CarStatus_Position::_internal_longitude() const {
	return longitude_;
}
inline double CarStatus_Position::longitude() const {
	// @@protoc_insertion_point(field_get:CarStateProtocol.CarStatus.Position.longitude)
	return _internal_longitude();
}
inline void CarStatus_Position::_internal_set_longitude(double value) {

	longitude_ = value;
}
inline void CarStatus_Position::set_longitude(double value) {
	_internal_set_longitude(value);
	// @@protoc_insertion_point(field_set:CarStateProtocol.CarStatus.Position.longitude)
}

// double altitude = 3;
inline void CarStatus_Position::clear_altitude() {
	altitude_ = 0;
}
inline double CarStatus_Position::_internal_altitude() const {
	return altitude_;
}
inline double CarStatus_Position::altitude() const {
	// @@protoc_insertion_point(field_get:CarStateProtocol.CarStatus.Position.altitude)
	return _internal_altitude();
}
inline void CarStatus_Position::_internal_set_altitude(double value) {

	altitude_ = value;
}
inline void CarStatus_Position::set_altitude(double value) {
	_internal_set_altitude(value);
	// @@protoc_insertion_point(field_set:CarStateProtocol.CarStatus.Position.altitude)
}

// -------------------------------------------------------------------

// CarStatus

// .CarStateProtocol.CarStatus.Telemetry telemetry = 1;
inline bool CarStatus::_internal_has_telemetry() const {
	return this != internal_default_instance() && telemetry_ != nullptr;
}
inline bool CarStatus::has_telemetry() const {
	return _internal_has_telemetry();
}
inline void CarStatus::clear_telemetry() {
	if (GetArenaForAllocation() == nullptr && telemetry_ != nullptr) {
		delete telemetry_;
	}
	telemetry_ = nullptr;
}
inline const ::CarStateProtocol::CarStatus_Telemetry& CarStatus::_internal_telemetry() const {
	const ::CarStateProtocol::CarStatus_Telemetry* p = telemetry_;
	return p != nullptr ? *p : reinterpret_cast<const ::CarStateProtocol::CarStatus_Telemetry&>(
			::CarStateProtocol::_CarStatus_Telemetry_default_instance_);
}
inline const ::CarStateProtocol::CarStatus_Telemetry& CarStatus::telemetry() const {
	// @@protoc_insertion_point(field_get:CarStateProtocol.CarStatus.telemetry)
	return _internal_telemetry();
}
inline void CarStatus::unsafe_arena_set_allocated_telemetry(
		::CarStateProtocol::CarStatus_Telemetry* telemetry) {
	if (GetArenaForAllocation() == nullptr) {
		delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(telemetry_);
	}
	telemetry_ = telemetry;
	if (telemetry) {

	} else {

	}
	// @@protoc_insertion_point(field_unsafe_arena_set_allocated:CarStateProtocol.CarStatus.telemetry)
}
inline ::CarStateProtocol::CarStatus_Telemetry* CarStatus::release_telemetry() {

	::CarStateProtocol::CarStatus_Telemetry* temp = telemetry_;
	telemetry_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
	auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
	if (GetArenaForAllocation() != nullptr) {
		temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
	}
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
	return temp;
}
inline ::CarStateProtocol::CarStatus_Telemetry* CarStatus::unsafe_arena_release_telemetry() {
	// @@protoc_insertion_point(field_release:CarStateProtocol.CarStatus.telemetry)

	::CarStateProtocol::CarStatus_Telemetry* temp = telemetry_;
	telemetry_ = nullptr;
	return temp;
}
inline ::CarStateProtocol::CarStatus_Telemetry* CarStatus::_internal_mutable_telemetry() {

	if (telemetry_ == nullptr) {
		auto* p = CreateMaybeMessage<::CarStateProtocol::CarStatus_Telemetry>(GetArenaForAllocation());
		telemetry_ = p;
	}
	return telemetry_;
}
inline ::CarStateProtocol::CarStatus_Telemetry* CarStatus::mutable_telemetry() {
	::CarStateProtocol::CarStatus_Telemetry* _msg = _internal_mutable_telemetry();
	// @@protoc_insertion_point(field_mutable:CarStateProtocol.CarStatus.telemetry)
	return _msg;
}
inline void CarStatus::set_allocated_telemetry(::CarStateProtocol::CarStatus_Telemetry* telemetry) {
	::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
	if (message_arena == nullptr) {
		delete telemetry_;
	}
	if (telemetry) {
		::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
				::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CarStateProtocol::CarStatus_Telemetry>::GetOwningArena(telemetry);
		if (message_arena != submessage_arena) {
			telemetry = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
					message_arena, telemetry, submessage_arena);
		}

	} else {

	}
	telemetry_ = telemetry;
	// @@protoc_insertion_point(field_set_allocated:CarStateProtocol.CarStatus.telemetry)
}

// .CarStateProtocol.CarStatus.State state = 2;
inline void CarStatus::clear_state() {
	state_ = 0;
}
inline ::CarStateProtocol::CarStatus_State CarStatus::_internal_state() const {
	return static_cast< ::CarStateProtocol::CarStatus_State >(state_);
}
inline ::CarStateProtocol::CarStatus_State CarStatus::state() const {
	// @@protoc_insertion_point(field_get:CarStateProtocol.CarStatus.state)
	return _internal_state();
}
inline void CarStatus::_internal_set_state(::CarStateProtocol::CarStatus_State value) {

	state_ = value;
}
inline void CarStatus::set_state(::CarStateProtocol::CarStatus_State value) {
	_internal_set_state(value);
	// @@protoc_insertion_point(field_set:CarStateProtocol.CarStatus.state)
}

// .CarStateProtocol.Stop stop = 3;
inline bool CarStatus::_internal_has_stop() const {
	return this != internal_default_instance() && stop_ != nullptr;
}
inline bool CarStatus::has_stop() const {
	return _internal_has_stop();
}
inline void CarStatus::clear_stop() {
	if (GetArenaForAllocation() == nullptr && stop_ != nullptr) {
		delete stop_;
	}
	stop_ = nullptr;
}
inline const ::CarStateProtocol::Stop& CarStatus::_internal_stop() const {
	const ::CarStateProtocol::Stop* p = stop_;
	return p != nullptr ? *p : reinterpret_cast<const ::CarStateProtocol::Stop&>(
			::CarStateProtocol::_Stop_default_instance_);
}
inline const ::CarStateProtocol::Stop& CarStatus::stop() const {
	// @@protoc_insertion_point(field_get:CarStateProtocol.CarStatus.stop)
	return _internal_stop();
}
inline void CarStatus::unsafe_arena_set_allocated_stop(
		::CarStateProtocol::Stop* stop) {
	if (GetArenaForAllocation() == nullptr) {
		delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stop_);
	}
	stop_ = stop;
	if (stop) {

	} else {

	}
	// @@protoc_insertion_point(field_unsafe_arena_set_allocated:CarStateProtocol.CarStatus.stop)
}
inline ::CarStateProtocol::Stop* CarStatus::release_stop() {

	::CarStateProtocol::Stop* temp = stop_;
	stop_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
	auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
	if (GetArenaForAllocation() != nullptr) {
		temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
	}
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
	return temp;
}
inline ::CarStateProtocol::Stop* CarStatus::unsafe_arena_release_stop() {
	// @@protoc_insertion_point(field_release:CarStateProtocol.CarStatus.stop)

	::CarStateProtocol::Stop* temp = stop_;
	stop_ = nullptr;
	return temp;
}
inline ::CarStateProtocol::Stop* CarStatus::_internal_mutable_stop() {

	if (stop_ == nullptr) {
		auto* p = CreateMaybeMessage<::CarStateProtocol::Stop>(GetArenaForAllocation());
		stop_ = p;
	}
	return stop_;
}
inline ::CarStateProtocol::Stop* CarStatus::mutable_stop() {
	::CarStateProtocol::Stop* _msg = _internal_mutable_stop();
	// @@protoc_insertion_point(field_mutable:CarStateProtocol.CarStatus.stop)
	return _msg;
}
inline void CarStatus::set_allocated_stop(::CarStateProtocol::Stop* stop) {
	::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
	if (message_arena == nullptr) {
		delete stop_;
	}
	if (stop) {
		::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
				::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CarStateProtocol::Stop>::GetOwningArena(stop);
		if (message_arena != submessage_arena) {
			stop = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
					message_arena, stop, submessage_arena);
		}

	} else {

	}
	stop_ = stop;
	// @@protoc_insertion_point(field_set_allocated:CarStateProtocol.CarStatus.stop)
}

// -------------------------------------------------------------------

// CarCommand

// repeated .CarStateProtocol.Stop stops = 1;
inline int CarCommand::_internal_stops_size() const {
	return stops_.size();
}
inline int CarCommand::stops_size() const {
	return _internal_stops_size();
}
inline void CarCommand::clear_stops() {
	stops_.Clear();
}
inline ::CarStateProtocol::Stop* CarCommand::mutable_stops(int index) {
	// @@protoc_insertion_point(field_mutable:CarStateProtocol.CarCommand.stops)
	return stops_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CarStateProtocol::Stop >*
CarCommand::mutable_stops() {
	// @@protoc_insertion_point(field_mutable_list:CarStateProtocol.CarCommand.stops)
	return &stops_;
}
inline const ::CarStateProtocol::Stop& CarCommand::_internal_stops(int index) const {
	return stops_.Get(index);
}
inline const ::CarStateProtocol::Stop& CarCommand::stops(int index) const {
	// @@protoc_insertion_point(field_get:CarStateProtocol.CarCommand.stops)
	return _internal_stops(index);
}
inline ::CarStateProtocol::Stop* CarCommand::_internal_add_stops() {
	return stops_.Add();
}
inline ::CarStateProtocol::Stop* CarCommand::add_stops() {
	::CarStateProtocol::Stop* _add = _internal_add_stops();
	// @@protoc_insertion_point(field_add:CarStateProtocol.CarCommand.stops)
	return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CarStateProtocol::Stop >&
CarCommand::stops() const {
	// @@protoc_insertion_point(field_list:CarStateProtocol.CarCommand.stops)
	return stops_;
}

// .CarStateProtocol.CarCommand.Action action = 2;
inline void CarCommand::clear_action() {
	action_ = 0;
}
inline ::CarStateProtocol::CarCommand_Action CarCommand::_internal_action() const {
	return static_cast< ::CarStateProtocol::CarCommand_Action >(action_);
}
inline ::CarStateProtocol::CarCommand_Action CarCommand::action() const {
	// @@protoc_insertion_point(field_get:CarStateProtocol.CarCommand.action)
	return _internal_action();
}
inline void CarCommand::_internal_set_action(::CarStateProtocol::CarCommand_Action value) {

	action_ = value;
}
inline void CarCommand::set_action(::CarStateProtocol::CarCommand_Action value) {
	_internal_set_action(value);
	// @@protoc_insertion_point(field_set:CarStateProtocol.CarCommand.action)
}

// -------------------------------------------------------------------

// Stop

// string to = 1;
inline void Stop::clear_to() {
	to_.ClearToEmpty();
}
inline const std::string& Stop::to() const {
	// @@protoc_insertion_point(field_get:CarStateProtocol.Stop.to)
	return _internal_to();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Stop::set_to(ArgT0&& arg0, ArgT... args) {

	to_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
	// @@protoc_insertion_point(field_set:CarStateProtocol.Stop.to)
}
inline std::string* Stop::mutable_to() {
	std::string* _s = _internal_mutable_to();
	// @@protoc_insertion_point(field_mutable:CarStateProtocol.Stop.to)
	return _s;
}
inline const std::string& Stop::_internal_to() const {
	return to_.Get();
}
inline void Stop::_internal_set_to(const std::string& value) {

	to_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Stop::_internal_mutable_to() {

	return to_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Stop::release_to() {
	// @@protoc_insertion_point(field_release:CarStateProtocol.Stop.to)
	return to_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Stop::set_allocated_to(std::string* to) {
	if (to != nullptr) {

	} else {

	}
	to_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), to,
					 GetArenaForAllocation());
	// @@protoc_insertion_point(field_set_allocated:CarStateProtocol.Stop.to)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace CarStateProtocol

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::CarStateProtocol::CarStatus_State> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CarStateProtocol::CarStatus_State>() {
	return ::CarStateProtocol::CarStatus_State_descriptor();
}
template <> struct is_proto_enum< ::CarStateProtocol::CarCommand_Action> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CarStateProtocol::CarCommand_Action>() {
	return ::CarStateProtocol::CarCommand_Action_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_CarStateProtocol_2eproto
